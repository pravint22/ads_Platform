import logging
import nest_asyncio
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filters

# Allow nested event loops (required for Colab)
nest_asyncio.apply()

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Configuration ---
BASE_URL = "https://vk25cdn.viralkand.com/8000/{}.mp4"
START_VIDEO = 8000
VIDEOS_PER_AD_CYCLE = 3  # How many videos before showing an ad
BOT_USERNAME = "YOUR_BOT_USERNAME_HERE" # REPLACE THIS with your actual bot username (without @)

# --- Bot Functions ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /start command. Supports deep linking (e.g., /start 8005)."""
    user = update.effective_user
    
    # Initialize user credits if they don't exist
    if 'credits' not in context.user_data:
        context.user_data['credits'] = VIDEOS_PER_AD_CYCLE
    
    # Check if the user clicked a shared link (e.g., /start 8005)
    if context.args and context.args[0].isdigit():
        video_number = int(context.args[0])
        context.user_data['current_video'] = video_number
        await send_video(update, context, video_number)
    else:
        # Normal start
        context.user_data['current_video'] = START_VIDEO
        await update.message.reply_text(
            f'Hi {user.mention_html()}! üëã\n\n'
            'I will send you videos from the collection.\n'
            f'üéÅ You get {VIDEOS_PER_AD_CYCLE} free videos before watching an ad.\n\n'
            'Commands:\n'
            '/reset - Restart from the beginning',
            parse_mode='HTML'
        )
        await send_video(update, context, START_VIDEO)

async def send_video(update: Update, context: ContextTypes.DEFAULT_TYPE, video_number: int) -> None:
    """Send video with Share, Previous, and Next buttons."""
    video_url = BASE_URL.format(video_number)
    
    # Get current credits (default to 3 if not set)
    credits = context.user_data.get('credits', VIDEOS_PER_AD_CYCLE)
    
    # 1. Create Share Link (Direct access to this video)
    # This creates a link like: https://t.me/share/url?url=https://t.me/MyBot?start=8005
    # Replace 'YOUR_BOT_USERNAME_HERE' at the top with your actual bot username!
    bot_link = f"https://t.me/{BOT_USERNAME}?start={video_number}"
    share_url = f"https://t.me/share/url?url={bot_link}&text=Check+out+Video+%23{video_number}!"

    # 2. Define Buttons
    
    # Row 1: Share Button
    row1 = [InlineKeyboardButton("üì§ Share Video", url=share_url)]
    
    # Row 2: Previous & Next
    row2 = []
    
    # Previous Button
    row2.append(InlineKeyboardButton("‚¨ÖÔ∏è Prev", callback_data='prev'))

    # Next Button Logic (Check Credits)
    if credits > 0:
        # If user has credits, show normal Next button
        row2.append(InlineKeyboardButton(f"Next ({credits} left) ‚û°", callback_data='next'))
    else:
        # If credits are 0, show Ad button to unlock more
        mini_app_url = context.bot_data.get('mini_app_url', '')
        row2.append(InlineKeyboardButton("üîì Watch Ad to Unlock", web_app=WebAppInfo(url=mini_app_url)))

    keyboard = [row1, row2]
    reply_markup = InlineKeyboardMarkup(keyboard)

    try:
        # Helper text
        caption = f"üìπ <b>Video #{video_number}</b>"
        
        if update.callback_query:
            # If updated from a button click
            await update.callback_query.message.reply_video(
                video=video_url,
                caption=caption,
                reply_markup=reply_markup,
                parse_mode='HTML'
            )
        else:
            # If sent as a new message
            await update.message.reply_video(
                video=video_url,
                caption=caption,
                reply_markup=reply_markup,
                parse_mode='HTML'
            )
            
    except Exception as e:
        logger.error(f"Error sending video {video_number}: {e}")
        error_message = f"‚ùå Could not load video #{video_number}"
        if update.callback_query:
            await update.callback_query.message.reply_text(error_message, reply_markup=reply_markup)
        else:
            await update.message.reply_text(error_message, reply_markup=reply_markup)

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle Next and Prev buttons."""
    query = update.callback_query
    await query.answer() # Acknowledge the click
    
    current_video = context.user_data.get('current_video', START_VIDEO)
    
    if query.data == 'next':
        # Check credits just in case
        credits = context.user_data.get('credits', VIDEOS_PER_AD_CYCLE)
        
        if credits > 0:
            # Deduct 1 credit
            context.user_data['credits'] = credits - 1
            
            # Go to next video
            next_video = current_video + 1
            context.user_data['current_video'] = next_video
            await send_video(update, context, next_video)
        else:
            # Should not happen if UI is correct, but safe fallback
            await query.message.reply_text("‚ö†Ô∏è You need to watch an ad to continue!")

    elif query.data == 'prev':
        # Previous button does NOT consume credits
        prev_video = current_video - 1
        # Prevent going below 0 or start video if you prefer
        if prev_video < 0: 
            prev_video = 0
            
        context.user_data['current_video'] = prev_video
        await send_video(update, context, prev_video)

    elif query.data == 'reset':
        context.user_data['current_video'] = START_VIDEO
        context.user_data['credits'] = VIDEOS_PER_AD_CYCLE # Optional: Reset credits on reset?
        await send_video(update, context, START_VIDEO)

async def handle_web_app_data(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle data sent from the mini app after watching ad."""
    try:
        data = update.message.web_app_data.data
        
        # Verify the data sent from your HTML page
        # Assuming your HTML sends JSON: {"action": "ad_completed", ...} or string "ad_watched"
        # Adjust logic to match your exact HTML output. 
        # Here checking for basic string match or simple JSON parsing
        
        is_valid = False
        if data == "ad_watched":
            is_valid = True
        elif "ad_completed" in data: # If it's a JSON string
            is_valid = True

        if is_valid:
            # 1. Refill Credits
            context.user_data['credits'] = VIDEOS_PER_AD_CYCLE
            
            # 2. Advance to Next Video
            current_video = context.user_data.get('current_video', START_VIDEO)
            next_video = current_video + 1
            context.user_data['current_video'] = next_video

            await update.message.reply_text(
                "‚úÖ <b>Ad Completed!</b>\n"
                f"üéâ You earned {VIDEOS_PER_AD_CYCLE} more videos.",
                parse_mode='HTML'
            )

            # 3. Send the video
            await send_video(update, context, next_video)
        else:
            await update.message.reply_text("‚ùå Ad verification failed.")

    except Exception as e:
        logger.error(f"Error handling web app data: {e}")

async def reset_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Reset command."""
    context.user_data['current_video'] = START_VIDEO
    context.user_data['credits'] = VIDEOS_PER_AD_CYCLE
    await update.message.reply_text("üîÑ Resetting...")
    await send_video(update, context, START_VIDEO)

# --- Main Execution ---
def main():
    # 1. ENTER YOUR TOKEN HERE
    BOT_TOKEN = 'YOUR_TELEGRAM_BOT_TOKEN' 
    
    # 2. ENTER YOUR MINI APP URL HERE
    MINI_APP_URL = 'https://ads-platform-zena.vercel.app/'

    if BOT_TOKEN == 'YOUR_TELEGRAM_BOT_TOKEN':
        print("‚ùå Error: Please put your actual Bot Token in the code.")
        return

    application = Application.builder().token(BOT_TOKEN).build()
    
    # Store global config
    application.bot_data['mini_app_url'] = MINI_APP_URL

    # Handlers
    application.add_handler(CommandHandler("start", start)) # Handles /start and deep links
    application.add_handler(CommandHandler("reset", reset_command))
    application.add_handler(CallbackQueryHandler(button_callback))
    application.add_handler(MessageHandler(filters.StatusUpdate.WEB_APP_DATA, handle_web_app_data))

    print("ü§ñ Bot is running...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
            
